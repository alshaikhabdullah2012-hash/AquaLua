# AquaLua Python Wrapper Generator
# Auto-generates AquaLua bindings for ANY Python library

import inspect
import importlib
import sys
import subprocess
from typing import Any, Dict, List

class PythonLibraryWrapper:
    """Automatically wrap Python libraries for AquaLua"""
    
    def __init__(self):
        self.wrapped_libraries = {}
        self.function_cache = {}
    
    def wrap_library(self, library_name: str) -> str:
        """Generate AquaLua wrapper code for any Python library"""
        try:
            # Import the library
            lib = importlib.import_module(library_name)
            
            # Analyze library structure
            functions = self._get_functions(lib)
            classes = self._get_classes(lib)
            constants = self._get_constants(lib)
            
            # Generate AquaLua code
            aqualua_code = self._generate_wrapper_code(library_name, functions, classes, constants)
            
            # Cache the wrapper
            self.wrapped_libraries[library_name] = aqualua_code
            
            return aqualua_code
            
        except ImportError:
            # Try to install the library
            print(f"Installing {library_name}...")
            subprocess.check_call([sys.executable, "-m", "pip", "install", library_name])
            return self.wrap_library(library_name)
    
    def _get_functions(self, lib) -> List[tuple]:
        """Extract all functions from library"""
        functions = []
        for name, obj in inspect.getmembers(lib):
            if inspect.isfunction(obj) or inspect.isbuiltin(obj):
                try:
                    sig = inspect.signature(obj)
                    functions.append((name, obj, sig))
                except (ValueError, TypeError):
                    # Handle functions without signatures
                    functions.append((name, obj, None))
        return functions
    
    def _get_classes(self, lib) -> List[tuple]:
        """Extract all classes from library"""
        classes = []
        for name, obj in inspect.getmembers(lib):
            if inspect.isclass(obj):
                methods = inspect.getmembers(obj, predicate=inspect.ismethod)
                classes.append((name, obj, methods))
        return classes
    
    def _get_constants(self, lib) -> List[tuple]:
        """Extract constants and variables"""
        constants = []
        for name, obj in inspect.getmembers(lib):
            if not name.startswith('_') and not callable(obj) and not inspect.ismodule(obj):
                constants.append((name, obj))
        return constants
    
    def _generate_wrapper_code(self, lib_name: str, functions: List, classes: List, constants: List) -> str:
        """Generate complete AquaLua wrapper code"""
        
        safe_name = lib_name.replace('.', '_').replace('-', '_')
        
        code = f'''# Auto-generated AquaLua wrapper for {lib_name}
# Generated by AquaLua Python Bridge

# Import the Python library
let {safe_name} = python_import("{lib_name}")

# Library constants
'''
        
        # Add constants
        for name, value in constants:
            if isinstance(value, (int, float, str, bool)):
                code += f'let {safe_name}_{name} = {repr(value)}\n'
        
        code += '\n# Library functions\n'
        
        # Add functions
        for name, func, sig in functions:
            if sig:
                params = list(sig.parameters.keys())
                param_str = ', '.join(params)
                code += f'''function {safe_name}_{name}({param_str}):
    return python_call("{lib_name}", "{name}", [{param_str}])

'''
            else:
                code += f'''function {safe_name}_{name}(*args):
    return python_call("{lib_name}", "{name}", args)

'''
        
        code += '# Library classes\n'
        
        # Add classes
        for class_name, cls, methods in classes:
            code += f'''class {safe_name}_{class_name}:
    function __init__(self, *args):
        self._python_obj = python_call("{lib_name}", "{class_name}", args)
    
'''
            # Add class methods
            for method_name, method in methods:
                if not method_name.startswith('_'):
                    code += f'''    function {method_name}(self, *args):
        return python_call_method(self._python_obj, "{method_name}", args)
    
'''
        
        # Add convenience functions
        code += f'''
# Convenience functions
function load_{safe_name}():
    return python_import("{lib_name}")

function {safe_name}_available():
    return python_package_available("{lib_name}")

function install_{safe_name}():
    return python_install_package("{lib_name}")

# Usage example:
# {safe_name}_obj = load_{safe_name}()
# result = {safe_name}_function_name(args)
'''
        
        return code

# Pre-generate wrappers for popular libraries
POPULAR_LIBRARIES = [
    'numpy', 'pandas', 'matplotlib', 'scipy', 'sklearn', 'torch', 'tensorflow',
    'cv2', 'PIL', 'requests', 'beautifulsoup4', 'flask', 'django', 'fastapi',
    'transformers', 'datasets', 'accelerate', 'diffusers', 'timm', 'torchvision',
    'torchaudio', 'librosa', 'spacy', 'nltk', 'gensim', 'plotly', 'seaborn',
    'statsmodels', 'networkx', 'sympy', 'numba', 'dask', 'ray', 'joblib'
]

def generate_all_wrappers():
    """Generate wrappers for all popular libraries"""
    wrapper = PythonLibraryWrapper()
    
    print("üêç Generating AquaLua wrappers for Python libraries...")
    
    for lib in POPULAR_LIBRARIES:
        try:
            print(f"Wrapping {lib}...")
            code = wrapper.wrap_library(lib)
            
            # Save wrapper to file
            filename = f"aqualua_{lib.replace('.', '_').replace('-', '_')}_wrapper.aq"
            with open(filename, 'w') as f:
                f.write(code)
            
            print(f"‚úì {lib} wrapper generated")
            
        except Exception as e:
            print(f"‚úó Failed to wrap {lib}: {e}")
    
    print(f"üéâ Generated wrappers for {len(POPULAR_LIBRARIES)} libraries!")

def wrap_custom_library(library_name: str):
    """Wrap any custom Python library"""
    wrapper = PythonLibraryWrapper()
    return wrapper.wrap_library(library_name)

if __name__ == "__main__":
    # Generate wrappers for popular libraries
    generate_all_wrappers()
    
    # Example: Wrap a custom library
    custom_wrapper = wrap_custom_library("your_custom_library")
    print("Custom library wrapped!")